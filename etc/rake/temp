#!/bin/bash

REPO="$HOME/.garden/etc"
RAKE="$HOME/.config/rake"
PACK="" # leaf currently being processed

# {{{ -- awk land ---
read -r -d '' AWK <<'EOF'
BEGIN {
  FS=": "
} {
  # get indent in twos
  match($0, /^ */)
  indent = RLENGTH / 2

  # strip indent from the key
  key=substr($1, RLENGTH + 1)
  com=substr(key, 1, 1)

  # skip comments
  if (com != "#" && length(key) > 0) {
    val = ""
    # get everything after the first delimiter match
    for (i = 2; i <= NF; i++) {
      val = (val)($i)": "
    }
    # remove trailing delimiter
    val = substr(val, 1, length(val) - 2)

    # https://stackoverflow.com/a/21189044
    vname[indent] = key
    for (i in vname) {
      if (i > indent) { delete vname[i] }
    }
    if (length(val) > 0) {
      path = ""
      for (i = 0; i < indent; i++) {
        path = (path)(vname[i])"_"
      }
      if (substr(val, 1, 8) == "require ") {
        #print "  "
        #print ". "val
        printf("%s '%s'\n", (val), (prefix)(path)(key)"_")
        #print "  "
      } else {
        printf("__%s=%s\n", (prefix)(path)(key), val);
      }
    }
  }
}
EOF
# }}}

require() {
  local prefix="$2"
  local output="$(awk -v prefix="$prefix" "$AWK" "$REPO/rake/$1")"
  while read -r line; do
    if [[ $line == "require "* ]]; then
      eval "$line"
    else
      echo "$line"
    fi
  done <<< "$output"
}

eval "$(require conf.yaml)" # load config

# -- utils --

once() { # run function 2 in leaf 1 once if defined
  PACK="$1"
  . "$REPO/$PACK/leaf.sh"
  if declare -F "$2" > /dev/null; then
    "$2" ; unset "$2"
  fi
}

readme() { # generate a readme based on currently raked leaves
  local txt="### Leaves currently being raked"$'\n'"\`\`\`"$'\n'
  for p in $RAKE/* ; do txt+="${p/$RAKE\//}"$'\n' ; done
  txt+="\`\`\`"$'\n'
  txt+="See [rake](https://github.com/tsbohc/.garden/tree/master/etc/rake) for more info."$'\n\n'
  txt+="> This readme is generated automatically and is always up to date."
  echo "$txt" > "$REPO/readme.md"
}

# -- template engine --

template() { # render a string with __context
  local input="$1"
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr="${BASH_REMATCH[0]}"
    body="${BASH_REMATCH[1]}"
    while [[ $body =~ $leaf_re ]]; do
      KEY="__${BASH_REMATCH[1]}"
      body="${body/${BASH_REMATCH[0]}/${!KEY}}"
    done
    input="${input/$expr/$body}"
  done
  echo "$input"
}

# -- leaf hooks --

render() {
  local source="$REPO/$PACK/$1"
  local target="$RAKE/$PACK/$1"
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() {
  [[ "$1" == *"$RAKE"* ]] && local source="$1" || local source="$REPO/$PACK/$source"
  local target="${2/\~/$HOME}"
  ln -sfn "$source" "$target"
}

unlink() {
  local target="${1/\~/$HOME}"
  [[ -L "$target" ]] && rm "$target"
}

rake() {
  if [[ -d "$REPO/$1" ]]; then
    once "$1" rake
    mkdir -p "$RAKE/$1"
  fi
}

unrake() {
  if [[ -d "$RAKE/$1" ]]; then
    once "$1" unrake
    rm -r "$RAKE/$1"
  fi
}

subcmd="$1" ; shift
case "$subcmd" in
  s|-s|setup)  for p in "$@"; do rake   "$p"; done ; readme ;;
  r|-r|remove) for p in "$@"; do unrake "$p"; done ; readme ;;
  l|-l|list)   for p in $RAKE/*; do echo "${p/$RAKE\//}"; done ;;
  *) echo "rake - tiny .garden management and templating framework"$'\n' \
          "  <setup> or <remove> leaves"$'\n' \
          "  <list> installed leaves" ;;
esac

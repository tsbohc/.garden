#!/bin/bash

# TODO i could loop through installed packages sourcing them and running the autostart function
# that's the easiest most portable way (errorless, too)

REPOSITORY="$HOME/.garden/etc"
CACHE="$HOME/.config/rake"
PACKAGE=""
REMOVE="NO"

# util

out() { echo "$@" ; }
log() {
  if [[ "$verbose" == "yes" ]]; then
    echo -e "$1: \033[0;37m${2//$HOME/\~}\033[0m" >&2
  fi
}

function?() { declare -F "$1" > /dev/null ; }
cached?() { [[ "$1" == *"$CACHE"* ]] ; }
remove?() { [[ "$REMOVE" == "YES" ]] ; }

# readme

readme() {
  # generate a readme with currently raked leaves
  # {{{
  local text="### Leaves currently being raked
\`\`\`"
  for p in $CACHE/*; do
    text="$text
${p/$CACHE\//}"
  done
  text="$text
\`\`\`
See [rake](https://github.com/tsbohc/.garden/tree/master/etc/rake) for more info.

> This readme is generated automatically and is always up to date."
  # FIXME the link

  echo "$text" > "$REPOSITORY/readme.md"
  log "update" "$REPOSITORY/readme.md"
  # }}}
}

# hooks ░░ ▒▒ ▓▓

unlink() {
  local target_path="$1"
  local target_path="${target_path/\~/$HOME}"

  if [[ -L "$target_path" ]]; then
    log "remove" "$target_path"
    rm "$target_path"
  fi
}

link() {
  local source_path="$1"
  local target_path="$2"
  local target_path="${target_path/\~/$HOME}"

  if ! remove?; then
    if ! cached? "$source_path"; then
      local source_path="$REPOSITORY/$PACKAGE/$1"
      #local cache_target_path="$CACHE/$PACKAGE/$1"
      #log "copy" "$cache_source_path -> $cache_target_path"
      #mkdir -p "$(dirname "$cache_target_path")"
      #cp -r "$cache_source_path" "$cache_target_path"
    fi

    log "link" "$source_path -> $target_path"
    mkdir -p "$(dirname "$target_path")"
    ln -sfn "$source_path" "$target_path"
  else
    unlink "$target_path"
  fi
}

render() {
  local source_path="$REPOSITORY/$PACKAGE/$1"
  local target_path="$CACHE/$PACKAGE/$1"

  if ! remove?; then
    log "render" "$source_path -> $target_path"
    local source_data="$(<"$source_path")"
    local target_data="$(./umai "$source_data")"
    mkdir -p "$(dirname "$target_path")"
    echo "$target_data" > "$target_path"
    out "$target_path"
  else
    out "$target_path"
  fi
}

# main

install() {
  PACKAGE="$1"
  . "$REPOSITORY/$PACKAGE/leaf.sh"

  log "-i $PACKAGE: $about"

  if ! [[ -d "$CACHE/$PACKAGE" ]]; then
    mkdir -p "$CACHE/$PACKAGE"
  fi

  if function? rake; then
    rake
    unset rake
  fi

  MYPATH+=("$path")
}

remove() {
  PACKAGE="$1"
  . "$REPOSITORY/$PACKAGE/leaf.sh"
  REMOVE="YES"

  log "-r $PACKAGE: $about"
  if function? rake; then
    rake
    unset rake
  fi

  if function? unrake; then
    unrake
    unset unrake
  fi

  if [[ -d "$CACHE/$PACKAGE" ]]; then
    log "remove" "$CACHE/$PACKAGE"
    rm -r "$CACHE/$PACKAGE"
  fi

  MYPATH+=("$path")
}

# arg parse

opt="$1"
shift

case "$opt" in
  -i|--install)
    for p in "${@}"; do
      if [[ -d "$REPOSITORY/$p" ]]; then
        install "$p"
      fi
    done
    readme
    ;;
  -u|--update)
    for p in "${@}"; do
       update_package_path=${p/$REPOSITORY\//}
       update_package_name="$(echo "$update_package_path" | cut -d/ -f1)"
       if [[ -d "$CACHE/$update_package_name" ]]; then
         install "$update_package_name"
         echo "installing $update_package_name" > ~/rake
       fi
    done
    ;;
  -r|--remove)
    for p in "${@}"; do
      if [[ -d "$CACHE/$p" ]]; then
        remove "$p"
      fi
    done
    readme
    ;;
  *)
    log "no command is given"
    ;;
esac

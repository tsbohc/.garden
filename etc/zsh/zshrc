#### Added by Zinit's installer
#if [[ ! -f $HOME/.zinit/bin/zinit.zsh ]]; then
#    print -P "%F{33}▓▒░ %F{220}Installing %F{33}DHARMA%F{220} Initiative Plugin Manager (%F{33}zdharma/zinit%F{220})…%f"
#    command mkdir -p "$HOME/.zinit" && command chmod g-rwX "$HOME/.zinit"
#    command git clone https://github.com/zdharma/zinit "$HOME/.zinit/bin" && \
#        print -P "%F{33}▓▒░ %F{34}Installation successful.%f%b" || \
#        print -P "%F{160}▓▒░ The clone has failed.%f%b"
#fi

# find ... | xargs wc -l -- count lines/etc in project

export PATH=$HOME/.garden/bin:$HOME/.garden/etc/polybar/modules:$PATH

source "$HOME/.zinit/bin/zinit.zsh"
autoload -Uz _zinit
(( ${+_comps} )) && _comps[zinit]=_zinit
### End of Zinit's installer chunk

export BLOSSOM_ENV="$HOME/.garden/etc"
export BLOSSOM_colo="kohi"

export EDITOR=nvim
export TERMINAL=alacritty

autoload -Uz compinit ; compinit # completion
zinit light Aloxaf/fzf-tab

# z.lua
__ZLUA_PATH="$HOME/.local/z.lua"
eval "$(lua $HOME/.local/z.lua --init zsh enhanced once fzf)"

# setopts

setopt auto_cd                   # cd into directories if only path is given
setopt no_case_glob              # case-insensitive globbing
setopt hist_ignore_space         # [ ]print -s to history

setopt prompt_subst              # support $() in prompt

setopt no_auto_menu
setopt no_menu_complete

unsetopt beep

# history

HISTFILE=~/.cache/histfile
HISTSIZE=1000
SAVEHIST=$HISTSIZE
setopt append_history hist_ignore_all_dups hist_ignore_space hist_reduce_blanks share_history

# misc

# remove that annoying bold slash at the end of paths
zle_highlight[(r)suffix:*]="suffix:fg=foreground"


# prompt

__prompt_symbol="››"
#❯◆»
__prompt_success_color=green
__prompt_failure_color=red

# {{{
::prompt::current_dir() {
  echo -n "%~"
}

::prompt::return_status() {
  echo -n "%B%(?.%F{$__prompt_success_color}.%F{$__prompt_failure_color})$__prompt_symbol%b%f"
}

::prompt::git_status() {
  if [[ "$(git status --porcelain 2>/dev/null)" != "" ]] ; then
    echo -n ", %F{$__prompt_success_color}$(git rev-parse --abbrev-ref HEAD 2> /dev/null)%f"
    MODIFIED=$(git status --short | wc -l)
    if [ $MODIFIED -gt 0 ]; then
      echo -n "+$MODIFIED"
    fi
  fi
}

PROMPT='$(::prompt::return_status) '
RPROMPT='$(::prompt::current_dir)$(::prompt::git_status)'

# }}}

#umai-() { export "UMAI_$1"="$2" ; }
#
#umai-i() { 
#  umai "$(find $dotfiles -type f -name "*.umai" | fzf)"
#}

#umai- ENV "$HOME/.garden/etc"
#umai- VARSETS_DIR "$HOME/.garden/etc/varsets"
#umai- colo "kohi"

umai() {
  lua5.1 ~/code/umai/umai --varsets ~/.garden/etc/varsets "$@"
}

umai!() {
  cd ~/code/umai
  ./build.sh
  cd - >/dev/null
  lua5.1 ~/code/umai/umai "$@" --varsets ~/.garden/etc/varsets - $(find ~/.garden/etc -type f -name "*.umai" -printf '%p ')
  #umai "$@" - $(find ~/.garden/etc -type f -name "*.umai" -printf "%p ")
}

umai-fzf() {
  lua5.1 ~/code/umai/umai "$@" - $(find ~/.garden/etc -type f -name "*.umai" | fzf)
}

# fzf

export FZF_DEFAULT_OPTS='--color=bg:-1,bg+:-1,hl:15,hl+:15,fg:7,fg+:7,info:7,prompt:7,pointer:4,header:15 --margin=0,2 --pointer="◇" --prompt="  "'

# aliases

alias yt-dl-best='youtube-dl -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best"'

alias v='nvim'
alias :q='exit'
alias :qw='exit'
alias :q!='exit'
alias please='sudo'

# ls
alias ls='ls -F --color=auto'
alias sl='ls'
alias la='ls -A'
alias ll='ls -lA'
alias l.='ls -A | egrep "^\."'
alias l='ls'

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# ask for confirmation
alias cp="cp -iv"
alias mv='mv -iv'
alias rm='rm -iv'

alias rrsh='curl -s -L https://raw.githubusercontent.com/keroserene/rickrollrc/master/roll.sh | bash'
alias font-grep='fc-list | grep'

# probably a bad idea
#sudo() { [ "$1" = "v" ] && sudoedit "$2" || command sudo "$@" ; }

# ls after cd except when going back to ~
#cd() {
#  builtin cd "$@"
#  [ ! "$(pwd)" = "$HOME" ] && la --group-directories-first || return 0
#}

# nvim as manpage viewer
m() { man "$1" | nvim -u ~/src/pager.vim ; }

ex() {
  if [ -f $1 ]; then
    case $1 in
      *.tar.bz2) tar xjf $1    ;;
      *.tar.gz)  tar xzf $1    ;;
      *.bz2)     bunzip2 $1    ;;
      *.rar)     unrar x $1    ;;
      *.gz)      gunzip $1     ;;
      *.tar)     tar xf $1     ;;
      *.tbz2)    tar xjf $1    ;;
      *.tgz)     tar xzf $1    ;;
      *.zip)     unzip $1      ;;
      *.Z)       uncompress $1 ;;
      *.7z)      7z x $1       ;;
      *.deb)     ar x $1       ;;
      *.tar.xz)  tar xf $1     ;;
      *.tar.zst) unzstd $1     ;;
      *) echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

new-bash-script() {
  touch "$1"
  echo "#!/bin/bash" > "$1"
  chmod +x "$1"
}

# git push via $EDITOR
# {{{
function gp() {
  if [ -z "$BUFFER" ]; then
    BUFFER="git add -A && git commit -v && git push"
  else
    BUFFER="git add -A && git commit -m \"$BUFFER\" && git push"
  fi
  zle accept-line # <cr>
}
# }}}
zle -N gp
bindkey "^g" gp

# simple fuzzy history
# {{{
::fuzzy_history() {
  local output
  output=$( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | tail --lines 200 | awk '{ $1=""; print substr($0,2) }' | fzf --tac --no-sort --height "15" --no-info --reverse --bind=up:down,down:up)
  echo "$output"
}

::fuzzy_history::keybind() {
  local output
  output="$(::fuzzy_history)"
  zle reset-prompt
  if [ ! "$output" = "" ]; then
    BUFFER=""             # clear whatever is on the line
    LBUFFER+="${output}"  # append selection from fzf
  fi
  return 0
}

hh() {
  local output
  output="$(::fuzzy_history)"
  if [ ! "$output" = "" ]; then
    print -z "$output"
  fi
  return 0
}
# }}}
zle -N ::fuzzy_history::keybind
bindkey "^[[A" ::fuzzy_history::keybind

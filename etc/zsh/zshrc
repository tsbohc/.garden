# zmodload zsh/zprof

# ;; path

# TODO redo this from hori via a symlink to ~/.bin or something
dotgarden=~/.garden

typeset -U PATH path # ensure only unique entries in $PATH

if [ -d "$dotgarden/bin" ]; then
  while read -r p; do
    path+="$p"
  done < <(find "$dotgarden/bin" -type d -not -name '_*')
fi

# pathadd "$HOME/.local/bin/" # shouldn't this already be in there?

# ;; zsh settings

# history
export HISTSIZE=100000
export SAVEHIST=$HISTSIZE

setopt hist_ignore_all_dups
setopt hist_save_no_dups
setopt hist_reduce_blanks
setopt inc_append_history

# other
setopt share_history
setopt auto_cd
setopt no_case_glob
setopt no_auto_menu
setopt no_menu_complete

setopt prompt_subst

unsetopt beep # beep is the strongest warrior!

# ;; gripes and grievances
zle_highlight[(r)suffix:*]="suffix:fg=foreground" # remove that annoying bold slash at the end of paths


# ;; completion

# https://gist.github.com/ctechols/ca1035271ad134841284
# compile zcompdump in the background once a day
# - '#q' is an explicit glob qualifier that makes globbing work within zsh's [[ ]] construct.
# - 'N' makes the glob pattern evaluate to nothing when it doesn't match (rather than throw a globbing error)
# - '.' matches "regular files"
# - 'mh+24' matches files (or directories or whatever) that are older than 24 hours.
autoload -Uz compinit
{ setopt extendedglob
  for zcompdump in $ZDOTDIR/.zcompdump(#qN.mh+24); do
    if [[ -s "$zcompdump" && (! -s "${zcompdump}.zwc" || "$zcompdump" -nt "${zcompdump}.zwc") ]]; then
      zcompile "$zcompdump"
    fi
  done
  unsetopt extendedglob
} &!
compinit -C

# completion for hori-hori
# compdef '_path_files -/ -W /home/sean/.garden/etc/' hori

# compdefas () {
#   if (($+_comps[$1])); then
#     compdef $_comps[$1] ${^@[2,-1]}=$1
#   fi
# }
# compdefas _xbps-install xvi # fails, compdef xvi=xbps-install is ok though


if [ -d "$dotgarden/bin/cl/_aliases" ]; then
  # echo "sourcing aliases"
  for f in "$dotgarden/bin/cl/_aliases/"*; do
    # echo "$f"
    emulate sh -c "source $f"
  done
fi
















# ;; exports

export EDITOR=nvim # TODO nvim -> vim -> vi
export TERMINAL=alacritty # TODO check for it first
# export FZF_DEFAULT_OPTS='--color=bg:-1,bg+:-1,hl:15,hl+:15,fg:7,fg+:7,info:7,prompt:7,pointer:1,header:15 --margin=0,2 --pointer="›" --prompt="  "'

# xdg stuff
export XDG_DATA_HOME=$HOME/.local/share
export XDG_CONFIG_HOME=$HOME/.config
export XDG_STATE_HOME=$HOME/.local/state
export XDG_CACHE_HOME=$HOME/.cache

export XDG_DESKTOP_DIR="$HOME/top"
export XDG_DOCUMENTS_DIR="$HOME/aux"
export XDG_DOWNLOAD_DIR="$HOME/dow"
export XDG_MUSIC_DIR="$HOME/mus"
export XDG_PICTURES_DIR="$HOME/pic"
export XDG_PUBLICSHARE_DIR="$HOME/pub"
export XDG_TEMPLATES_DIR="$HOME/tem"
export XDG_VIDEOS_DIR="$HOME/vid"

export HISTFILE=${XDG_CACHE_HOME}/bash_history
export CUDA_CACHE_PATH=${XDG_CACHE_HOME}/nv
export GRADLE_USER_HOME=${XDG_DATA_HOME}/gradle
export _JAVA_OPTIONS=-Djava.util.prefs.userRoot="$XDG_CONFIG_HOME"/java
export NPM_CONFIG_USERCONFIG=${XDG_CONFIG_HOME}/npm/npmrc

# qt5 scaling
export QT_ENABLE_HIGHDPI_SCALING=0
export QT_AUTO_SCREEN_SCALE_FACTOR=0

# ;; prompt

# ⬡⬢ 🢒▶⯅⯆▲▼⯁ ●»›►▻▸▹×

prompt_symbol="\$"
prompt_git_color=green
prompt_success_color=blue
prompt_failure_color=red
prompt_failure_symbol="×"

ansi() {
  echo -n "%F{$1}$2%f"
}

::prompt_current_dir() {
  echo -n "%~"
}

::prompt_return_status() {
  echo -n "%B%(?.%F{$prompt_success_color}$prompt_symbol.%F{$prompt_failure_color}$prompt_failure_symbol)%b%f"
}

::prompt_time() { # from https://github.com/sindresorhus/pretty-time-zsh
  local seconds d h m s
  local -a human=()
  seconds=$1
  d=$(( seconds / 60 / 60 / 24 ))
  h=$(( seconds / 60 / 60 % 24 ))
  m=$(( seconds / 60 % 60 ))
  s=$(( seconds % 60 ))

  (( d > 0 )) && human+="${d}d" && : ${color:=${GEOMETRY_TIME_COLOR_LONG:-red}}
  (( h > 0 )) && human+="${h}h" && : ${color:=${GEOMETRY_TIME_COLOR_NEUTRAL:-default}}
  (( m > 0 )) && human+="${m}m"
  (( s > 0 )) && human+="${s}s" && : ${color:=${GEOMETRY_TIME_COLOR_SHORT:-green}}

  ${2:-false} && echo ${(j: :)human} || echo " $human[1]"
}

::prompt_git_branch() { # branch name
  git rev-parse 2>/dev/null || return
  git rev-parse --abbrev-ref HEAD 2>/dev/null
}

::prompt_git_status() { # dirty or clean status
  git rev-parse 2>/dev/null || return
  if [[ -z "$(git status --porcelain --ignore-submodules)" ]]; then
    ansi green "⬢"
  else
    ansi green "⬡"
  fi
}

::prompt_git_modified() { # count of dirty files
  git rev-parse 2>/dev/null || return
  local modified; modified="$(git status --porcelain --ignore-submodules | wc -l)"
  if [ $modified -gt 0 ]; then
    ansi grey " +$modified"
  fi
}

::prompt_git_time() { # time since last commit
  git rev-parse 2>/dev/null || return
  local last_commit; last_commit=$(git log -1 --pretty=format:'%at' 2>/dev/null)
  [[ -z "$last_commit" ]] && return
  local now; now=$(date +%s)
  local seconds_since_last_commit; seconds_since_last_commit=$((now - last_commit))
  ansi cyan "$(::prompt_time $seconds_since_last_commit)"
}

if [[ -n $SSH_CONNECTION ]]; then
  PCMD() {
    echo "$(ansi blue "$(whoami)@$(hostname)") $(::prompt_current_dir) $(::prompt_return_status) "
  }
else
  PCMD() {
    echo "$(::prompt_current_dir) $(::prompt_return_status) "
  }
fi

RCMD() { # non-blocking
  echo "$(::prompt_git_branch)$(::prompt_git_time)$(::prompt_git_modified)$(ansi blue "$prompt_cmd_elapsed")"
}

PROMPT='$(PCMD)'
RPROMPT=''

# prompt right

preexec() {
  prompt_cmd_start=$(date +%s)
  echo -ne "\033]0;\$ ${1} // ${PWD/#$HOME/~}\007" # set alacritty title to "pwd $ last command run"
  # TODO the above could techincally be reset after the command finishes, so
  # that windows with running commands have a special title
}

ASYNC_PROC=0
function precmd() { # executed before each prompt
  # setup cmd time tracking
  if [ $prompt_cmd_start ]; then
    local now; now=$(date +%s)
    local delta; delta=$(($now - $prompt_cmd_start))
    if (( delta > 5 )); then
      prompt_cmd_elapsed="$(::prompt_time delta)"
    else
      prompt_cmd_elapsed=""
    fi
    unset prompt_cmd_start
  else
    unset prompt_cmd_elapsed
  fi

  function async() {
    printf "%s" "$(RCMD)" > "/tmp/zsh_prompt_$$" # save to temp file
    kill -s USR1 $$ # signal parent
  }

  # do not clear RPROMPT, let it persist
  # kill child if necessary
  if [[ "${ASYNC_PROC}" != 0 ]]; then
    kill -s HUP $ASYNC_PROC >/dev/null 2>&1 || :
  fi
  # start background computation
  async &!
  ASYNC_PROC=$!
}

function TRAPUSR1() {
  RPROMPT="$(cat /tmp/zsh_prompt_$$)" # read from temp file
  \rm -f /tmp/zsh_prompt_$$ # clean up
  ASYNC_PROC=0 # reset proc number
  zle && zle reset-prompt # redisplay
}






# ;; plugins

# fzf completion
if ! [ -d "$HOME/.config/zsh-fzf-compe" ]; then
  git clone https://github.com/Aloxaf/fzf-tab "$HOME/.config/zsh-fzf-compe"
fi
source $HOME/.config/zsh-fzf-compe/fzf-tab.plugin.zsh
zstyle ':fzf-tab:*' fzf-flags "--info=hidden"

# z.lua
if [ -d "$HOME/.config/z-lua" ]; then
  export _ZL_DATA="$HOME/.local/.zlua"
  export _ZL_FZF_FLAG="--no-sort --info=hidden --bind tab:down --bind shift-tab:up --bind change:first --cycle"
  eval "$(lua "$HOME/.config/z-lua/z.lua" --init zsh fzf)"

  function n() {
    dir="$(z -l "$@" | \
      while read -r frecency line; do
        echo "${line/$HOME/~}"
      done | fzf \
        --prompt="z " \
        --reverse \
        --cycle \
        --height 35% \
        --no-sort --tac --info=hidden \
        --bind tab:down \
        --bind shift-tab:up \
        --bind change:first)"
    dir="${dir/\~/$HOME}"
    [ -n "$dir" ] && cd "$dir"
  }
else
  git clone https://github.com/skywind3000/z.lua "$HOME/.config/z-lua"
fi



# TODO look into a that script for this:

# simple fuzzy history
::fuzzy_history() {
  local output
  output=$( ([ -n "$ZSH_NAME" ] && fc -l 1 || history) | tail -n 2000 | awk '{ $1=""; print substr($0,2) }' | fzf --tac --no-sort --height "15" --no-info --reverse --bind=up:down,down:up)
  echo "$output"
}

::fuzzy_history::keybind() {
  local output
  output="$(::fuzzy_history)"
  zle reset-prompt
  if [ ! "$output" = "" ]; then
    BUFFER=""             # clear whatever is on the line
    LBUFFER+="${output}"  # append selection from fzf
  fi
  return 0
}

zle -N ::fuzzy_history::keybind
bindkey "^[[A" ::fuzzy_history::keybind






# ask pass
if type rofi-askpass >/dev/null; then
  export SUDO_ASKPASS=$(which rofi-askpass)
fi




# -- less begin
export LESSHISTSIZE=${XDG_CACHE_HOME}/less_history

less_prompt="" # the dots close ifs (i think)
less_prompt+=".?f%f:stdin.\ " # ?f (if filename is known) %f (then print it) : (else print "stdin")
less_prompt+=".?lt%lt:?pt%pt\%.." # ?lt (if line number) %lt (then print it) :?pt (elif percent) %pt (else print percent) \% (print %)
less_prompt+=".?L\/%L.\ "

export LESS="--use-color --ignore-case --incsearch --prompt $less_prompt"

export LESS_TERMCAP_mb=$'\e[31m'    # begin bold
export LESS_TERMCAP_md=$'\e[1;33m'    # section titles and options
export LESS_TERMCAP_me=$'\e[0m'     # reset bold/blink
export LESS_TERMCAP_so=$'\e[0m'     # begin reverse video
export LESS_TERMCAP_us=$'\e[1;37m'    # italic
export LESS_TERMCAP_se=$'\e[0m'     # reset reverse video
export LESS_TERMCAP_ue=$'\e[0m'     # reset underline
# -- less end

# -- aliases begin

alias v='nvim' # TODO check nvim -> vim -> vi

# ls
if type exa >/dev/null; then
  alias ls='exa'
  alias sl='exa'
  alias l='exa'
  alias la='exa -a'
  alias ll='exa -la'
  alias l.='exa -a | egrep "^\."'
else
  alias ls='ls -F --color=auto'
  alias l='ls'
  alias sl='ls'
  alias la='ls -A'
  alias ll='ls -lA'
  alias l.='ls -A | egrep "^\."'
fi

# cd
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'

# ask for confirmation
alias cp="cp -iv"
alias mv='mv -iv'
alias rm='rm -iv'

function gasp() { # easy git push in one command
  git add -A && git commit -v && git push
}

function cd() { # ls after cd except when going back to ~
  builtin cd "$@"
  [ ! "$(pwd)" = "$HOME" ] && la || return 0
}

function mkcd() {
  mkdir -p "$@" && cd "$@"
}

# jokes
alias please='sudo'

# void
export XDEB_PKGROOT=$HOME/.cache/xdeb

# zprof

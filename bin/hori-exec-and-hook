#!/usr/bin/env bash

#: tiny dotfiles management and templating framework

# TODO
# replace dirname with string manipulation

# -- templating engine

import() { # transpile toml-like config into into bash variables
  local prefix=$2
  local section_re='^\[(.*)\]'
  local kvpair_re='(.*)[[:space:]]=[[:space:]](.*)'
  local import_re='\$\((import[[:space:]].*)\)'
  while read -r line; do
    if [[ $line =~ $section_re ]]; then
      local section=${BASH_REMATCH[1]/\./\_}_
    elif [[ $line =~ $kvpair_re ]]; then
      if [[ $prefix == "$section" ]]; then
        echo "__${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
      else
        echo "__${prefix}${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
      fi
    elif [[ $line =~ $import_re ]]; then
      eval "${BASH_REMATCH[1]} ${section}"
    fi
  done < "$REPO/hori-hori/$1"
}

template() { # render a string with config as context
  local input=$1
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr=${BASH_REMATCH[0]}
    body=${BASH_REMATCH[1]}
    while [[ $body =~ $leaf_re ]]; do
      key=__${BASH_REMATCH[1]}
      body=${body/${BASH_REMATCH[0]}/${!key}}
    done
    input=${input/$expr/$body}
  done
  echo "$input"
}

# -- actions

render() { #!ACTIONS render <file> and return its path
  local source=$REPO/$PACK/$1
  local target=$HORI/$PACK/$1
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { #!ACTIONS create symlink from <source> to <target>
  local source ; [[ $1 == *"$HORI"* ]] && source=$1 || source=$REPO/$PACK/$1
  local target=${2/\~/$HOME}
  mkdir -p "$(dirname "$target")"
  ln -sfn "$source" "$target"
}

unlink() { #!ACTIONS remove <symlink>
  local target=${1/\~/$HOME}
  [[ -L $target ]] && rm "$target"
}

launch() { #!ACTIONS kill existing <process> and run <command>
  pkill -x "$1" ; sleep 0.2 ; "$@"
}

install() { #!ACTIONS list the required dependencies
  local IFS=$'\n' ; echo "$*"
}


yell() { echo "$@" 1>&2 ; }

prep() {
  HORI="$HOME/.config/hori"
  if [[ -f "$HORI/repository.hori" ]]; then
    REPO="$(<"$HORI/repository.hori")"
    [[ ! -d $REPO ]] && unset REPO
  fi
  if [[ -z $REPO ]]; then
    REPO="$(find ~ -type f -name "repository.hori" -print -quit 2>/dev/null)" ; REPO=${REPO%/*}
    yell "hori:prep found repo at <$REPO>"
    echo "$REPO" > "$HORI/repository.hori"
  fi
  [[ -z $REPO ]] && { yell "could not find repo, aborting..." ; exit ; }
}

list() {
  case $* in
    -i|--installed) packages=("$HORI/"*) ;;
    -a|--available) packages=("$REPO/"*) ;;
    *) packages=("$@") ;;
  esac
  for p in "${packages[@]}"; do
    p="${p##*/}"
    if [[ -f "$REPO/$p/hori.sh" ]]; then
      echo "$p"
    #else
      #yell "hori:list <$p> is not a valid package in <$REPO>"
    fi
  done
}

hook() {
  PACK=$2
  h=$1
  (
    . "$REPO/$PACK/hori.sh"
    if declare -F "$h" > /dev/null; then
      #case $h in
      #  add) mkdir -p "$HORI/$2" ;; # FIXME setup -> add
      #esac
      echo "running <$h> in <$PACK>"
      #"$h" "$2" "$@"
      #case $h in
      #  del) [[ -d "${HORI:?}/$2" ]] && rm -r "${HORI:?}/$2" ;; # FIXME remove -> del
      #esac
    else
      yell "hori:hook <$h> not in <$PACK>"
    fi
  )
  unset PACK
}

exec() { # execute <hook> in <package(s)>
  local cmd=$1 ; shift
  while read -r p; do
    echo "running <$cmd> in <$p>"
    "$cmd" "$p"
  done < <(list "$@")
}

# -- main

section() {
  re="(.*)\(\)[[:space:]]\{[[:space:]]#!$1[[:space:]](.*)"
  echo "$1"
  while read -r line; do
    if [[ $line =~ $re ]]; then
      echo "  ${BASH_REMATCH[1]}	${BASH_REMATCH[2]}"
    fi
  done < "$0"
}

functions() {
  grep -E '^[[:space:]]*([[:alnum:]_]+[[:space:]]*\(\)|function[[:space:]]+[[:alnum:]_]+)' \
    "$REPO/$1/hori.sh"
}

help() {
  echo -e "${0##*/} - $(grep -Po -m 1 "^#: \K.*" "$0")\n"
  section "ACTIONS" | column -t -s $'\t'
}

prep
#eval "$(import conf)" && conf_status="evaluated"

cmd=$1 ; shift
case $cmd in
  -h|--help|"") help ;;
  ls) list "$@" ;;
  *) exec "hook $cmd" "$@" ;;
esac

exec functions -a

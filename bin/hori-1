#!/usr/bin/env bash
# shellcheck disable=SC1090,SC2015

#: tiny dotfiles management and templating framework

# TODO
# replace dirname with string manipulation

yell() { echo "$@" 1>&2 ; }

command -v dunstify &> /dev/null && \
  notify() { dunstify hori "$*" ; } || notify() { : ; }

# -- templating engine

import() { # transpile toml-like config into into bash variables
  local prefix=$2
  local section_re='^\[(.*)\]'
  local kvpair_re='(.*)[[:space:]]=[[:space:]](.*)'
  local import_re='\$\((import[[:space:]].*)\)'
  while read -r line; do
    if [[ $line =~ $section_re ]]; then
      local section=${BASH_REMATCH[1]/\./\_}_
    elif [[ $line =~ $kvpair_re ]]; then
      if [[ $prefix == "$section" ]]; then
        echo "__${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
      else
        echo "__${prefix}${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
      fi
    elif [[ $line =~ $import_re ]]; then
      eval "${BASH_REMATCH[1]} ${section}"
    fi
  done < "$REPO/hori-hori/$1"
}

template() { # render a string with config as context
  local input=$1
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr=${BASH_REMATCH[0]}
    body=${BASH_REMATCH[1]}
    while [[ $body =~ $leaf_re ]]; do
      key=__${BASH_REMATCH[1]}
      body=${body/${BASH_REMATCH[0]}/${!key}}
    done
    input=${input/$expr/$body}
  done
  echo "$input"
}

# -- actions

render() { # render <1:file> and return its path
  local source=$REPO/$PACK/$1
  local target=$HORI/$PACK/$1
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { # create symlink from <1:source> to <2:target>
  local source ; [[ $1 == *"$HORI"* ]] && source=$1 || source=$REPO/$PACK/$1
  local target=${2/\~/$HOME}
  mkdir -p "$(dirname "$target")"
  ln -sfn "$source" "$target"
}

unlink() { # remove <1:symlink>
  local target=${1/\~/$HOME}
  [[ -L $target ]] && rm "$target"
}

launch() { # kill existing <1:process> and run <@:command>
  pkill -x "$1" ; sleep 0.2 ; "$@"
}

install() { # list the required <*:dependencies>
  local IFS=$'\n' ; echo "$*"
}

list() {
  case $* in
    -i|--installed) packages=("$HORI/"*) ;;
    -a|--available) packages=("$REPO/"*) ;;
    *) packages=("$@") ;;
  esac
  for p in "${packages[@]}"; do
    p="${p##*/}"
    if [[ -f "$REPO/$p/hori.sh" ]]; then
      echo "$p"
    fi
  done
}

hook() { # execute <1:hook> in <@:packages>
  local h=$1 ; shift
  while read -r p; do
    PACK=$p ; (
      . "$REPO/$p/hori.sh"
      if declare -F "$h" > /dev/null; then
        case $h in
          autostart) notify "autostart $PACK" ;;
          add) mkdir -p "$HORI/$p" ;;
        esac
        echo "<$h> in <$p>"
        "$h"
        case $h in
          del) [[ -d "${HORI:?}/$p" ]] && rm -r "${HORI:?}/$p" ;;
        esac
      else
        yell "<$h> is not in <$p>"
      fi
    ) ; unset PACK
  done < <(list "$@")
}

# -- main

HORI="$HOME/.config/hori"
REPO=$(cat "$HORI/.repo" 2>/dev/null)

if [[ ! -f "$REPO/repository.hori" ]]; then
  REPO="$(find ~ -type f -name "repository.hori" -print -quit 2>/dev/null)"
  REPO=${REPO%/*}
  yell "hori:main found repo at <$REPO>"
  echo "$REPO" > "$HORI/.repo"
fi

[[ -f "$REPO/repository.hori" ]] || { yell "could not find repo, aborting..." ; exit ; }
eval "$(import conf)" || { yell "conf evaluation failed, aborting..." ; exit ; }

cmd=$1 ; shift
case $cmd in
  -h|--help|"") echo "\$ hori <hook> (<package(s)>|-i|-a)" ;;
  ls) list "$@" ;;
  *) hook "$cmd" "$@" ;;
esac
